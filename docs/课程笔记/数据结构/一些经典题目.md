
# 一些经典题目

## 1. 算法分析

1. $Nlog N^2和Nlog N^3$具有相同的增加速度
![[复杂度题1.png]]

2. 斐波那契数列**递归版本**的时间复杂度为$O(F_N)$，空间复杂度为$O(N)$；**迭代版本**的时间复杂度为$O(N)$，空间复杂度为$O(1)$
3. 主定理：
![[算法分析3.png]]

- 主定理内容如下：假设有 $T(N)=aT(N/b)+f(n)\ (a\ge 1,b\gt 1)$ 则
	- 如果存在常数$\varepsilon\gt 0$ ，使得 $f(n)=O(n^{\log_b a}-\varepsilon)$ ，则$T(N)=\Theta(n^{\log_b a})$
	- 如果 $f(n)=\Theta(n^{\log_b a})$，则 $T(N)=\Theta(n^{\log_b a}\log n)$
	- 如果存在常数$\varepsilon\lt 0$ ，使得 $f(n)=\Omega(n^{\log_b a}+\varepsilon)$ ，同时存在常数 $c\lt 1$ 使得对于充分大 $n$ 有 $af(n/b) \le cf(n)$ ，则 $T(N)=\Theta(f(n))$


### 定义补充

- $T(N)=O(f(N))\ \Rightarrow$  如果存在常数$c$和$n_0$，使得当$N\ge n_0$时，$T(N)\le cf(N)$，即T(N)增长比f(N) 慢 或 ==相同==
- $T(N)=\Omega (f(N))\ \Rightarrow$ 如果存在常数$c$和$n_0$，使得当$N\ge n_0$时，$T(N)\ge cf(N)$，即T(N)增长比f(N) 快 或 ==相同==
- $T(N)=\Theta(f(N))\ \Rightarrow$ 当且仅当 $T(N)=O(f(N))$ 且 $T(N)=\Omega (f(N))$ ,即T(N)与f(N)增长速度相同
- $T(N)=o(f(N))\ \Rightarrow$ $T(N)=O(f(N))$ 且 $T(N)\ne\Theta(f(N))$，即T(N)增长比f(N) ==慢==
- $T(N)=\omega(f(N))\ \Rightarrow$ $T(N)=\Omega (f(N))$ 且 $T(N)\ne\Theta(f(N))$，即T(N)增长比f(N) ==快==

注意阶乘增长速度比指数函数大： $2^n=O(n!)$

## 2. 线性表

1. To merge two singly linked ascending lists, both with _N_ nodes, into one singly linked ascending list, the minimum possible number of comparisons is: **N**
	最少的情况可以假设第一个链表为{1，2，3，4，5}，第二个链表为{6，7，8，9，10}。此时只用将6和1-5分别比较一次即可，因此最少需要比较N次。
	
	需要注意，merge的时间复杂度是$O(M+N)$

2. 判断循环队列为空的条件是 `Q.front==Q.rear` ，判断为满的条件是 `Q.front==(Q.rear+1)%Q.size`





## 3. 堆

1. 线性算法建堆
![[linear algorithm调整建堆法，时间复杂度O(N).png]]
Linear algorithm ， 意味着我们要用调整建堆法O(N) 而不是不断插入建堆O(NlogN)
具体而言，就是先无脑放入树中，然后从倒数第二排最后一个有子节点的节点（n/2）开始shiftdown，具体过程省略。
![[一些经典题目 2024-04-06 18.44.37.excalidraw]]

2. 最大堆的最小值在没有孩子的节点中
![[最大堆的最小值在没有孩子的节点中.png]]
其中$\lfloor \frac{n}{2} \rfloor$是最后一个节点的父亲，因此唯一有可能的是大于n/2的index

## 4. 树

1. 二叉树是度为2的树
**False** 
度为2的树要求每个节点最多只能有两棵子树，并且至少有一个节点有两棵子树。二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0；且二叉树的左右子树不能随意颠倒，普通树的子树没有左右之分。

2. 二叉搜索树的查找和Binary Search的时间复杂度相同
**False**
只有**平衡**的二叉搜索树才与折半查找时间复杂度相同

3. 二叉搜索树的最小元素一定位于树根的左子树
**False**
还有可能是根节点

4. 任何二叉树中，NULL指针个数比实际指针个数多
![[NULL比ACTUAL多.png]]

5. 将一个general tree $T$ 转换成 binary tree $BT$ ，则 $T$ 的后序遍历与$BT$的中序遍历相同，且二者前序遍历相同

6. 无论是前序中序还是后序，叶子节点的遍历顺序不变


## 5. 图

1. 一个weakly connected的digraph，边数最少的情况是树的形式
![[weaklyconnected的边数.png]]

最少|V|-1 采用树的形式

2. degree和为边数的两倍
![[degree和.png]]

$$\sum (degree)=2e, 得到32=12+12+d(v-7), 由于d<3,故8\le 2(v-7)。$$

3. sad
![[最短路径权值+1.png]]
每个Edge的权值+2，则路径的权值等于原来的值加上边的个数\*2，如果P的边数很多，就有可能不再是最短路径。

4. 如果图没有联通的话，最小生成树不存在

*The minimum spanning tree of any weighted graph ___*

- A. must be unique
- B. must not be unique
- C. exists but may not be unique
- D. may not exist

答案选 *D*


5. 欧拉图
![[欧拉图边的要求.png]]

20个点的完全图，每个vertex的度为19。欧拉图的每个点的度必须是一个偶数，因此可以使得每个点的度数为18，一条边对应两度，减少的边为：20/2 = 10

**相关定理**：

- 无向连通图 G 是==欧拉图==，当且仅当 G 不含奇数度结点( G 的所有结点度数为偶数)；
- 无向连通图 G 含有==欧拉通路==，当且仅当 G 有零个或两个奇数度的结点(这两个点为起点和终点)；
- 有向连通图 D 是==欧拉图==，当且仅当该图为连通图且 D 中每个结点的入度=出度；
- 有向连通图 D 含有==欧拉通路==，当且仅当该图为连通图且 D 中除两个结点外，其余每个结点的入度=出度，且此两点满足起始点s的入度=出度-1，结束点t的出度=入度-1 或两个点的入度=出度；

## 6. 排序

1. simple insertion sort 交换的次数不会超过逆序对的个数
![[simpleinsertionsort交换的次数不会超过逆序对的个数.png]]

10个元素逆序的话：有C(10,2)=45的逆序对，因此交换的数目不会大于45

2. 一趟后能确定一个最终位置的排序
![[一趟后能确定一个最终位置的排序.png]]

[一趟后能确定最终位置的排序](#)：堆排序，冒泡排序，快速排序，简单选择排序
![[铸币不知道插入排序.png]]

3. 递归的总数是不变的
![[递归的总数是不变的.png]]

4. 如何找到QuickSort合适的中间过程
![[如何找到QuickSort合适的中间过程.png]]

5. LSD基数排序做题
![[LSD基数排序.png]]

第一轮只看个位数，第二轮按照最后两位数对应的大小排列

## 7.哈希表

![[意义不明哈希.png]]

- 插入探针数的期望值优于线性寻址探针数
- 在table size是质数，且至少有一半空位的情况下，一个新元素一定可以通过quadratic probing(二次探测)插入
- 在Separate Chaining中，如果允许列表中出现重复的元素，插入通常优于删除(?看不懂)

---

![[Rehash.png]]

再散列将TableSize扩大两倍为20，再取最近的的质数23作为表长

---

![[二次探测法.png]]

有点没懂，等个人来教我

---


![[Rehash的必要条件按.png]]

改变冲突解决策略对于Rehashing来说不必要

---
