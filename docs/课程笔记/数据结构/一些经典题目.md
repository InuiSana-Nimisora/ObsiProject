
# 一些经典题目

## 1. 算法分析

1. $Nlog N^2和Nlog N^3$具有相同的增加速度
![[复杂度题1.png]]

2. 斐波那契数列**递归版本**的时间复杂度为$O(F_N)$，空间复杂度为$O(N)$；**迭代版本**的时间复杂度为$O(N)$，空间复杂度为$O(1)$


## 2. 线性表

1. To merge two singly linked ascending lists, both with _N_ nodes, into one singly linked ascending list, the minimum possible number of comparisons is: **N**
	最少的情况可以假设第一个链表为{1，2，3，4，5}，第二个链表为{6，7，8，9，10}。此时只用将6和1-5分别比较一次即可，因此最少需要比较N次。
	
	需要注意，merge的时间复杂度是$O(M+N)$

2. 判断循环队列为空的条件是 `Q.front==Q.rear` ，判断为满的条件是 `Q.front==(Q.rear+1)%Q.size`





## 3. 堆

1. 线性算法建堆
![[linear algorithm调整建堆法，时间复杂度O(N).png]]
Linear algorithm ， 意味着我们要用调整建堆法O(N) 而不是不断插入建堆O(NlogN)
具体而言，就是先无脑放入树中，然后从倒数第二排最后一个有子节点的节点（n/2）开始shiftdown，具体过程省略。
![[一些经典题目 2024-04-06 18.44.37.excalidraw]]

2. 最大堆的最小值在没有孩子的节点中
![[最大堆的最小值在没有孩子的节点中.png]]
其中$\lfloor \frac{n}{2} \rfloor$是最后一个节点的父亲，因此唯一有可能的是大于n/2的index

## 4. 树

1. 二叉树是度为2的树
**False** 
度为2的树要求每个节点最多只能有两棵子树，并且至少有一个节点有两棵子树。二叉树的要求是度不超过2，节点最多有两个叉，可以是1或者0；且二叉树的左右子树不能随意颠倒，普通树的子树没有左右之分。

2. 二叉搜索树的查找和Binary Search的时间复杂度相同
**False**
只有**平衡**的二叉搜索树才与折半查找时间复杂度相同

3. 二叉搜索树的最小元素一定位于树根的左子树
**False**
还有可能是根节点

4. 任何二叉树中，NULL指针个数比实际指针个数多
![[NULL比ACTUAL多.png]]

5. 将一个general tree $T$ 转换成 binary tree $BT$ ，则 $T$ 的后序遍历与$BT$的中序遍历相同，且二者前序遍历相同

6. 无论是前序中序还是后序，叶子节点的遍历顺序不变


## 5. 图

1. 一个weakly connected的digraph，边数最少的情况是树的形式
![[weaklyconnected的边数.png]]

最少|V|-1 采用树的形式

2. degree和为边数的两倍
![[degree和.png]]

$$\sum (degree)=2e, 得到32=12+12+d(v-7), 由于d<3,故8\le 2(v-7)。$$

3. sad
![[最短路径权值+1.png]]
每个Edge的权值+2，则路径的权值等于原来的值加上边的个数\*2，如果P的边数很多，就有可能不再是最短路径。



