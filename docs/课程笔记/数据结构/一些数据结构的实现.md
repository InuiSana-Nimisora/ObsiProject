# 一些数据结构的实现

## ADT : The Abbreviation of Abstract Data Type

## Sequential Linear List 顺序存储线性表

用数组表示线性表的优点是便于随机存取 **(所谓随机存取，就是通过首地址和元素的位序号值可以在O(1)的时间内找到指定的元素)**

顺序表的优点是**存储密度**(存储利用率)高

## Linked List 链表的创建与添加节点

单向链表通常有个dummy head，因此头指针存放的不是头结点的内容

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(PtrToNode)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

## Stack 栈

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

### 以链表的方式实现栈

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp 的作用就是释放空间
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

## Queue 队列(链表实现方式)

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

## Tree 树

由于$2n_2 + n_1 +1= n_2 +n_1+ n_0$ ，所以$n_2= n_0-1$，度为2的节点个数为叶结点个数减一

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree Left;
    Tree Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

### 从中序遍历和后序遍历得到一个二叉树

```c
Tree newnode(int data);
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N);
int main(void){
    int N;scanf("%d",&N);int inorder[N],postorder[N];
    for(int i=0;i<N;i++){
        scanf("%d",inorder+i);
    }
    for(int i=0;i<N;i++){
        scanf("%d",postorder+i);
    }Tree head=newnode(postorder[N-1]);
    createTree(head,inorder,postorder,0,N,N);
}
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N){
    Tree temp;
    int z;
    if(front>=rear){
        return NULL;
    }
    int indexh=Find(postorder[rear-1],inorder,0,N);
    int index=front-1;
    for(int i=rear-2;i>=front;i--){
        z=Find(postorder[i],inorder,0,N);
        if(z<indexh){
            index=i;
            break;
        }
    }if(rear-2<front){
        return NULL;
    }
    if(index==front-1){
        head->left=NULL;
        temp=newnode(postorder[rear-2]);
        head->right=temp;
    }else if(index==rear-2){
        head->right=NULL;
        temp=newnode(postorder[index]);
        head->left=temp;
    }else{
        temp=newnode(postorder[rear-2]);
        head->right=temp;
        temp=newnode(postorder[index]);
        head->left=temp;
    }if(head->left!=NULL)
    createTree(head->left,inorder,postorder, front,index+1,N);
    if(head->right!=NULL)
    createTree(head->right,inorder,postorder,index+1,rear-1,N);
}
/*若是想要以zigzagging order输出的话，建立两个栈，
 *第一个栈弹出顶端后依次将左节点和右节点压入第二个栈中；
 *第二个栈弹出顶端后一次将右节点和左节点压入第一个栈中，每个栈空了之后轮换到下一个栈
 */
```


### 线索二叉树 Threaded

建树的时候，每个节点是有两个指针（指向一左一右）的，N个节点，也就是2N个指针，但是实际上不是Null的只有N-1个，因为除了根都有一个指向这个节点，还有N+1个指针没有用，线索二叉树就是为了让这N+1个节点有用，指向的就是你的排序方式给出后，那个线性排列的“前驱”和“后驱”，左指针指向前驱，右指针指向后驱。

因此写选择题的时候可以先将遍历（无论是前序还是后序还是中序）列出来，再将虚线连上去。
![[线索二叉树.png]]

## Priority Queue 堆（优先队列

```c
typedef struct HeapStruct *PriorityQueue; //设为指针形式方便直接在函数中修改值
struct HeapStruct {
    int *Elements;
    int Capacity;
    int Size;
};
// 其实更多以数组的方式实现 左子树：2*index 右子树 2*index+1 父节点 index/2
// 注意，有个dummy head，根节点从index = 1开始
```


```c
PriorityQueue Initialize(int MaxElements){
	PriorityQueue H=(PriorityQueue)malloc(sizeof(struct HeapStruct));
	if(H==NULL)
		exit(1);
	H->Elements=(int*)malloc((MaxElements+1)*sizeof(int)); //留一个空位给dummyhead
	if(H->Elements==NULL)
		exit(1);
	H->Capacity=MaxElements;
	H->Size=0;
	return H;
}
```

```c
void Insert(int X,Priority H){
	int i;
	if(isFull(H)){
		return;
	}
	for(i=++H->Size;H->Elements[i/2]>X;i/=2){ //minHeap的情况
		H->Elements[i]=H->Elements[i/2];
	}H->Elements[i]=X;
}
```

### Delete操作
```c
//进行delete操作，思路是删除最小元素，将队尾元素移至root处，再下滤至符合要求
int DeleteMin(Priority H){
	int i,child;
	int MinElement,LastElement;
	if(isEmpty(H))
		return;
	MinElement=H->Elements[1];
	LastElement=H->Elements[H->Size--];
	for(i=1;i*2<=H->Size;i=child){
		child=i*2;
		if(child!=H->Size && H->Elements[child+1]<H->Elements[child])
			child++;
		if(LastElement>H->Elements[child])
			H->Elements[i]=H->Elements[child];
		else
			break;
	}
	H->Elements[i]=LastElement;
	return MinElement;
}
```

如果你已经定义过了PercolateDown的函数，你也可以直接使用来完成上述DeleteMin操作。

```c
void PercolateDown(int p,PriorityQueue H){ //下滤操作的时间复杂度为树的高度O(h)
    int min;
    while(2*p<=H->Size && 2*p+1<=H->Size){
        if(H->Elements[2*p]<H->Elements[2*p+1])
            min = 2*p;
        else
            min = 2*p+1;
        if(H->Elements[min]<H->Elements[H->Size+1]){
            H->Elements[p]=H->Elements[min];
            p=min;
        }else
            break;
    }//注意循环结束后还要加个判断左子树是否还可以down的操作，因为CompleteTree右子树可能不存在。
    if(2*p<=H->Size && H->Elements[2*p]<H->Elements[H->Size+1]){ /
        H->Elements[p]=H->Elements[2*p];
        p=p*2;
    }H->Elements[p]=H->Elements[H->Size+1];
}
void PercolateUp(int p,PriorityQueue H){
    int tmp;
    while(p/2>=1 && H->Elements[p/2]>H->Elements[p]){
        tmp=H->Elements[p/2];
        H->Elements[p/2] = H->Elements[p];
        H->Elements[p] = tmp;
        p=p/2;
    }
}

//具体调用如下:
H->Size--;
PercolateDown(1,H);
```

### 建堆操作

**对于未成堆的Heap，我们一般从$\lfloor \frac{n}{2} \rfloor$开始下滤，完成排序，并且时间复杂度为O(n)哦。**

$T=\sum_1^{h+1} 2^{h+1} -1 -2^h= 2^{h+1} -1-(h+1)=O(n)$

### d-heap

注意，d-heap指一个节点有d个孩子（当然还是完全树哦~）
```c
child(i,j) = d*(i-1)+2+j    (i是父亲结点的下标，j是第几个儿子，范围是0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (这是d-heap最后一个有叶子的结点。在heap里是size()/2)
```

### 堆排序

利用最大堆最大的元素在根节点的性质，可以对数组进行排序。

具体实现原理为:

- 先将初始的R[1,...,n]建立成最大堆，此时是无序堆，而堆顶是最大元素。
- 再将堆顶R[1]和最后一个元素R[n]交换，由此得到新的无序区R[1,...,n-1]与有序区R[n]。
- 将无序区再次建堆(只用对R[1]进行下滤操作即可)，重复上述操作。
- 直到无序区只剩下最后一个元素，可以得到递增序列。
## Disjoint Set 并查集

等价关系**R**的三个性质:

- **Reflexive** 自反性：
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** 对称性:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** 传递性：
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

一般将root的值设为其**树的大小的负值**

**如果要给长度为N的Union(数组实现)赋初值(即全为-1)，不能采用如下写法:**
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *实际上uni[N+1] = {0};也是不允许的，数组长度为变量的话不能赋初值；
    *况且这里写-1最多也只能把第一个赋为-1（即为-1,0,0,0,...）
    */
    --- --- --- --- ---
    //正确写法如下:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){
    //这里时间复杂度为O(N) ，将整个代码都拉跨了，有什么办法呢？
        uni[i]=-1;
    }
```

### 优化Find算法 路径压缩

```C
//优化过的find算法，找root的时候顺便减少了depth
//递归版本
int Find ( int X , DisjSet S ){
	if ( S[ X ] <= 0 )
		return X;
	else 
		return S[ X ] = Find( S[ X ], S );
}
```

```c
//迭代版本
int  Find ( int  X, DisjSet  S ){   
	int  root,trail,lead;

    for ( root = X; S[ root ] > 0; root = S[ root ] );  // find the root
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[ trail ] ;  
       S[ trail ] = root ;  
    }  //把路上遇到的节点全连接到root上
    return  root ;
}
```

### 合并 Union

```c
void SetUnion(int n1, int n2, int S){
	int root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
//按这种方式Union的并查集，则任何节点的深度均不会超过$log_2 N$
```


## Graph 图

#### Definition
- **G(V,E)**  : G代表图，V代表finite nonempty set of vertices(vertex的复数，顶点)，E代表finite set of edges

- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$

- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$

- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.

- **Complete Graph** : 边数最大的graph 
对于无向图，若V=n，则$E_{MAX}= C_n^2$；        
对于有向图，若V=n，则$E_{MAX} = 2*C_n^2 = P_n^2$

- **adjacent** : 相邻的
![[adjacent.png]]

- **Subgraph** : $G'\subset G\ if\ and\ only\ if\ V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$

- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}\ such\ that\ (v_p, v_{i1}),(v_{i1}, v_{i2}),..., (v_{in}, v_q)\ or\ <v_p, v_{i1}>,<v_{i1}, v_{i2}>,..., <v_{in}, v_q>\ belong\ to\ E(G)$

- **Length of Path** : path中边的个数(注意，是边)

- **Simple Path** : 路径没有重复的点(不包括首尾)

- **Circle** : 首尾相同的path

- **(Connected) Component of an undirected G** : 最大的connected subgraph

- **A tree** : a graph that is connected and acyclic 

- **A DAG** : a directed acyclic graph 一个有方向的不成圆的图

- **Strongly Connected** : 对于每一对$v_i\ v_j$，都分别存在从$v_i\ to\ v_j\ 以及\ v_j\ to\ v_i$的directed path

- **Weakly Connected** : 与上面相同，但是是无方向图中（直接将有方向图看作无方向图）

- **Degree(v)** : 与v相连的边的个数；如果是有方向图，则用in-degree表示指向v的边的个数，out-degree表示从v指出的边的个数。
也因此可以得到边的总数为degree(v)的和的一半(一条边由两个vertex共有)

- **topological order** : 拓扑序，a linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.


在实战中尽量用数组表示吧，用链表连接写的烂完了😂

### 判断序列Seq是否是拓扑序

```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYD命名太混乱了，记个思路就行
/*
*每次循环将从Seq[i]out的edge归零（不用归零，因为之后就不会调用Seq[i]对应的Vertex了）
*并且归零前检测一遍它指向的元素是否在Seq[i]前面，若在说明false，最后都没false就true
*/
```

