# 一些数据结构的实现

## ADT : The Abbreviation of Abstract Data Type

```
pandoc .\Project.md -s --highlight-style tango -o pr.pdf
```

## Sequential Linear List 顺序存储线性表

用数组表示线性表的优点是便于随机存取 **(所谓随机存取，就是通过首地址和元素的位序号值可以在O(1)的时间内找到指定的元素)**

顺序表的优点是**存储密度**(存储利用率)高

## Linked List 链表的创建与添加节点

单向链表通常有个dummy head，因此头指针存放的不是头结点的内容

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(PtrToNode)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

## Stack 栈

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

### 以链表的方式实现栈

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp 的作用就是释放空间
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

## Queue 队列(链表实现方式)

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

## Tree 树

由于$2n_2 + n_1 +1= n_2 +n_1+ n_0$ ，所以$n_2= n_0-1$，度为2的节点个数为叶结点个数减一

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    int Element;
    Tree Left;
    Tree Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

### 从中序遍历和后序遍历得到一个二叉树

```c
int main(void){
    Tree T;
    int inorder[MAXN], postorder[MAXN], N, i;
    scanf("%d", &N);
    for (i=0; i<N; i++) scanf("%d", &inorder[i]);
    for (i=0; i<N; i++) scanf("%d", &postorder[i]);
    T = BuildTree(inorder, postorder, N);
}
Tree BuildTree(int inorder[],int postorder[],int N){
    Tree root=(Tree)malloc(sizeof(struct TreeNode));
    int index;
    if(N<=0){
        return NULL;
    }else if(N==1){
        root->Element=postorder[N-1];
        root->Left=NULL;
        root->Right=NULL;
        return root;
    }
    root->Element=postorder[N-1];
    for(int i=0;i<N;i++)
        if(inorder[i]==postorder[N-1]){
            index=i;
            break;
        }
    root->Left=BuildTree(inorder,postorder,index);
    root->Right=BuildTree(inorder+index+1,postorder+index,N-index-1);
    return root;
}
/*若是想要以zigzagging order输出的话，建立两个栈，
 *第一个栈弹出顶端后依次将左节点和右节点压入第二个栈中；
 *第二个栈弹出顶端后一次将右节点和左节点压入第一个栈中，每个栈空了之后轮换到下一个栈
 */
```


### 线索二叉树 Threaded

建树的时候，每个节点是有两个指针（指向一左一右）的，N个节点，也就是2N个指针，但是实际上不是Null的只有N-1个，因为除了根都有一个指向这个节点，还有N+1个指针没有用，线索二叉树就是为了让这N+1个节点有用，指向的就是你的排序方式给出后，那个线性排列的“前驱”和“后驱”，左指针指向前驱，右指针指向后驱。

因此写选择题的时候可以先将遍历（无论是前序还是后序还是中序）列出来，再将虚线连上去。
![[线索二叉树.png]]

## Priority Queue 堆（优先队列

```c
typedef struct HeapStruct *PriorityQueue; //设为指针形式方便直接在函数中修改值
struct HeapStruct {
    int *Elements;
    int Capacity;
    int Size;
};
// 其实更多以数组的方式实现 左子树：2*index 右子树 2*index+1 父节点 index/2
// 注意，有个dummy head，根节点从index = 1开始
```


```c
PriorityQueue Initialize(int MaxElements){
	PriorityQueue H=(PriorityQueue)malloc(sizeof(struct HeapStruct));
	if(H==NULL)
		exit(1);
	H->Elements=(int*)malloc((MaxElements+1)*sizeof(int)); //留一个空位给dummyhead
	if(H->Elements==NULL)
		exit(1);
	H->Capacity=MaxElements;
	H->Size=0;
	return H;
}
```

```c
void Insert(int X,Priority H){
	int i;
	if(isFull(H)){
		return;
	}
	for(i=++H->Size;H->Elements[i/2]>X;i/=2){ //minHeap的情况
		H->Elements[i]=H->Elements[i/2];
	}H->Elements[i]=X;
}
```

### Delete操作
```c
//进行delete操作，思路是删除最小元素，将队尾元素移至root处，再下滤至符合要求
int DeleteMin(Priority H){
	int i,child;
	int MinElement,LastElement;
	if(isEmpty(H))
		return;
	MinElement=H->Elements[1];
	LastElement=H->Elements[H->Size--];
	for(i=1;i*2<=H->Size;i=child){
		child=i*2;
		if(child!=H->Size && H->Elements[child+1]<H->Elements[child])
			child++;
		if(LastElement>H->Elements[child])
			H->Elements[i]=H->Elements[child];
		else
			break;
	}
	H->Elements[i]=LastElement;
	return MinElement;
}
```

如果你已经定义过了PercolateDown的函数，你也可以直接使用来完成上述DeleteMin操作。

```c
void PercolateDown(int p,PriorityQueue H){ //下滤操作的时间复杂度为树的高度O(h)
    int min;
    while(2*p<=H->Size && 2*p+1<=H->Size){
        if(H->Elements[2*p]<H->Elements[2*p+1])
            min = 2*p;
        else
            min = 2*p+1;
        if(H->Elements[min]<H->Elements[H->Size+1]){
            H->Elements[p]=H->Elements[min];
            p=min;
        }else
            break;
    }//注意循环结束后还要加个判断左子树是否还可以down的操作，因为CompleteTree右子树可能不存在。
    if(2*p<=H->Size && H->Elements[2*p]<H->Elements[H->Size+1]){ /
        H->Elements[p]=H->Elements[2*p];
        p=p*2;
    }H->Elements[p]=H->Elements[H->Size+1];
}
void PercolateUp(int p,PriorityQueue H){
    int tmp;
    while(p/2>=1 && H->Elements[p/2]>H->Elements[p]){
        tmp=H->Elements[p/2];
        H->Elements[p/2] = H->Elements[p];
        H->Elements[p] = tmp;
        p=p/2;
    }
}

//具体调用如下:
H->Size--;
PercolateDown(1,H);
```

### 建堆操作

**对于未成堆的Heap，我们一般从$\lfloor \frac{n}{2} \rfloor$开始下滤，完成排序，并且时间复杂度为O(n)哦。**

$T=\sum_1^{h+1} 2^{h+1} -1 -2^h= 2^{h+1} -1-(h+1)=O(n)$

### d-heap

注意，d-heap指一个节点有d个孩子（当然还是完全树哦~）
```c
child(i,j) = d*(i-1)+2+j    (i是父亲结点的下标，j是第几个儿子，范围是0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (这是d-heap最后一个有叶子的结点。在heap里是size()/2)
```

### 堆排序

利用最大堆最大的元素在根节点的性质，可以对数组进行排序。

具体实现原理为:

- 先将初始的R[1,...,n]建立成最大堆，此时是无序堆，而堆顶是最大元素。
- 再将堆顶R[1]和最后一个元素R[n]交换，由此得到新的无序区R[1,...,n-1]与有序区R[n]。
- 将无序区再次建堆(只用对R[1]进行下滤操作即可)，重复上述操作。
- 直到无序区只剩下最后一个元素，可以得到递增序列。
## Disjoint Set 并查集

等价关系**R**的三个性质:

- **Reflexive** 自反性：
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** 对称性:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** 传递性：
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

一般将root的值设为其**树的大小的负值**

**如果要给长度为N的Union(数组实现)赋初值(即全为-1)，不能采用如下写法:**
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *实际上uni[N+1] = {0};也是不允许的，数组长度为变量的话不能赋初值；
    *况且这里写-1最多也只能把第一个赋为-1（即为-1,0,0,0,...）
    */
    --- --- --- --- ---
    //正确写法如下:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){
    //这里时间复杂度为O(N) ，将整个代码都拉跨了，有什么办法呢？
        uni[i]=-1;
    }
    --- --- --- --- ---
    //其实还真有方法
    #include<srting.h>
    int *uni=(int*)malloc(N*sizeof(int));
    memset(uni,-1,sizeof(uni));
    //对于整数数组，memset函数只能赋初值0或-1，请务必注意
```

```c
//一种动态分配的方法
int *uni;
uni=(int*)calloc(N+1,sizeof(int));
```

### 优化Find算法 路径压缩

```C
//优化过的find算法，找root的时候顺便减少了depth
//递归版本
int Find ( int X , DisjSet S ){
	if ( S[ X ] <= 0 )
		return X;
	else 
		return S[ X ] = Find( S[ X ], S );
}
```

```c
//迭代版本
int  Find ( int  X, DisjSet  S ){   
	int  root,trail,lead;

    for ( root = X; S[ root ] > 0; root = S[ root ] );  // find the root
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[ trail ] ;  
       S[ trail ] = root ;  
    }  //把路上遇到的节点全连接到root上
    return  root ;
}
```

### 合并 Union

```c
void SetUnion(int n1, int n2, int S){
	int root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
//按这种方式Union的并查集，则任何节点的深度均不会超过$log_2 N$
```


## Graph 图



```c
    graph=(int**)malloc(N*sizeof(int*));

    for(int i=0;i<N;i++){

        graph[i]=(int*)malloc(N*sizeof(int));

    }
    //二维数组动态分配内存，可以用来表示图
```

#### Definition
- **G(V,E)**  : G代表图，V代表finite nonempty set of vertices(vertex的复数，顶点)，E代表finite set of edges

- **Undirected Graph** : $(v_i,v_j)=(v_j,v_i)$

- **Directed Graph(digraph)** : $<v_i,v_j>\ne <v_j,v_i>$

- **Restriction** : (1) Self loop is not illegal;    (2) Multigraph is not considered.

- **Complete Graph** : 边数最大的graph 
对于无向图，若V=n，则$E_{MAX}= C_n^2$；        
对于有向图，若V=n，则$E_{MAX} = 2*C_n^2 = P_n^2$

- **adjacent** : 相邻的
![[adjacent.png]]

- **Subgraph** : $G'\subset G\ if\ and\ only\ if\ V(G')\subset V(G)\ \&\& \ E(G')\subset E(G)$

- **Path from $v_q\ to\ v_p$** : $\{v_p, v_{i1}, v_{i2},..., v_{in}, v_q\}\ such\ that\ (v_p, v_{i1}),(v_{i1}, v_{i2}),..., (v_{in}, v_q)\ or\ <v_p, v_{i1}>,<v_{i1}, v_{i2}>,..., <v_{in}, v_q>\ belong\ to\ E(G)$

- **Length of Path** : path中边的个数(注意，是边)

- **Simple Path** : 路径没有重复的点(不包括首尾)

- **Circle** : 首尾相同的path

- **(Connected) Component of an undirected G** : 最大的connected subgraph

- **A tree** : a graph that is connected and acyclic 

- **A DAG** : a directed acyclic graph 一个有方向的不成圆的图，也就是任意结点都无法通过一些有向边回到自身

- **Strongly Connected** : 对于每一对$v_i\ v_j$，都分别存在从$v_i\ to\ v_j\ 以及\ v_j\ to\ v_i$的directed path

- **Weakly Connected** : 与上面相同，但是是无方向图中（直接将有方向图看作无方向图）

- **Degree(v)** : 与v相连的边的个数；如果是有方向图，则用in-degree表示指向v的边的个数，out-degree表示从v指出的边的个数。
也因此可以得到边的总数为degree(v)的和的一半(一条边由两个vertex共有)

- **topological order** : 拓扑序，a linear ordering of the vertices of a graph such that, for any two vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.

### AOV network (Active on vertices)

在Digraph中，用顶点表示活动，用有向边$<v_{i}, v_{j}>$表示活动 i 是活动 j 的必须条件。这种有向图称为用顶点表示活动的网络，即AOV network。

根据定义，一个可行的AOV network必须是DAG (directed acyclic graph)。

为了解决这个问题，我们引入了拓扑序。

### 判断序列Seq是否是拓扑序

在实战中尽量用数组表示吧，用链表连接写的烂完了😂


```c
bool IsTopSeq(LGraph Graph,Vertex Seq[]){
    PtrToAdjVNode temp,pre;
    for(int i=0;i<Graph->Nv;i++){
        temp=(Graph->G)[Seq[i]-1].FirstEdge;
        while(temp!=NULL){
            for(int j=0;j<i;j++){
                if((temp->AdjV+1)==Seq[j]){
                    return false;
                }
            }
            pre=temp;
            temp=temp->Next;
        }
    }return true;
}

//BYD命名太混乱了，记个思路就行

/*
*每次循环将从Seq[i]out的edge归零
*修正：不用归零，因为之后就不会调用Seq[i]对应的Vertex了
*并且归零前检测一遍它指向的元素是否在Seq[i]前面，
*若在说明false，最后都没false就true
*/
```

```C
//HW中的实现
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[MaxVertexNum]; //AdjList[i]中存第i个vertex的out edge链表

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;

LGraph G=ReadG();
```


### Network Flow Problems 网络最大流问题

![[NetworkFlow问题.png]]

给定一个graph，确定头s以及尾t，求从s到t共有多少flow可以进入

[解决方法](#)

$G_f：流量图\ \ G_r：余量图\ \ ，初始时G_f为空，G_r和G相同$

1. 选择路径：在图$G_r$中任意选择一条源点到目标点的路径
2. 更新$G_f$：在$G_f$中添加该路径，路径的大小由最小流量决定
3. 更新$G_r$：如果路径的一部分为 $a->b$ 整条路径最小流量为q，$a->b$的本身流量为p，则$G_r$中添加$b->a$，流量为q，$a->b$的流量更新为p-q(如果为0则删去这条路径)
4. 重复1、2、3直到$G_r$中找不到路径

#### dfs算法实现 Depth-First Search

```cpp
int n, m, s, t; // s是源点，t是汇点
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // 到达终点，返回这条增广路的流量
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // 返回的条件是残余容量大于0、未访问过该点且接下来可以达到终点（递归地实现）
        // 传递下去的流量是边的容量与当前流量中的较小值
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // 这是链式前向星取反向边的一种简易的方法
            // 建图时要把cnt置为1，且要保证反向边紧接着正向边建立
            return c;
        }
    }
    return -1; // 无法到达终点
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
```

#### bfs算法实现 

```cpp
int n, m, s, t, last[MAXN], flow[MAXN];
inline int bfs()
{
    memset(last, -1, sizeof(last));
    queue<int> q;
    q.push(s);
    flow[s] = INF;
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        if (p == t) // 到达汇点，结束搜索
            break;
        for (int eg = head[p]; eg; eg = edges[eg].next)
        {
            int to = edges[eg].to, vol = edges[eg].w;
            if (vol > 0 && last[to] == -1) // 如果残余容量大于0且未访问过（所以last保持在-1）
            {
                last[to] = eg;
                flow[to] = min(flow[p], vol);
                q.push(to);
            }
        }
    }
    return last[t] != -1;
}
inline int EK()
{
    int maxflow = 0;
    while (bfs())
    {
        maxflow += flow[t];
        for (int i = t; i != s; i = edges[last[i] ^ 1].to) // 从汇点原路返回更新残余容量
        {
            edges[last[i]].w -= flow[t];
            edges[last[i] ^ 1].w += flow[t];
        }
    }
    return maxflow;
}
```

### Minimum Spanning Tree 最小生成树

[定义](#)
一个连通图的生成树是一个极小的连通子图，它包含图中所有n个顶点，但只有构成一棵树的n-1条边。

所谓一个**带权图**的==最小生成树==，就是图中**边的权值和最小的生成树**。


[属性](#)

- 一个图可以有多个生成树(==也可以有多个最小生成树==)
- 对于包含n个顶点的无向完全图最多包含$n^{n-2}$颗生成树。
- 生成树中不存在环
- 移除生成树的任意一条边都会导致图的不连通
- 在生成树中任意添加一条边都会构成环

#### Prim算法

1. 任意选择一个点，加入生成树(已经生成的部分)
2. 选择与这个点相连的权值最小的边和点加入到生成树
3. 对于已经生成的部分，再次重复2
4. 当所有点加入后，停止

#### Kruskal算法

1. 选择权值最小的边及与它相连的点加入生成树
2. 从原图中删去这条边
3. 选取权值最小的且不构成Circle的边和点加入生成树(==不要求和已经生成的部分相连==)
4. 从原图中删去这条边
5. 重复3、4直到包含所有点

在生成最小生成树MST的时候，可以采用==并查集==的数据结构来表示边的连接关系。


