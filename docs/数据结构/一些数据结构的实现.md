# 一些数据结构的实现
# 链表的创建与添加节点

```c
struct Node{
    int element;
    struct Node* next;
}
```



```c
typedef struct Node *PtrToNode;
struct Node {
    int element
    PtrToNode next;
};
PtrToNode a={0,NULL};
PtrToNode newnode=(Polynomial)malloc(sizeof(struct Node));
newnode->element=1;
newnode->next=NULL;
a->next=newnode;
```

# 栈的初始化

```c
struct stackrecord{
    int maxsize;
    int top;
    int *array;
};
struct stackrecord stack={Max,0};
stack.array=(int *)calloc(stack.maxsize+1,sizeof(int));
```

## 以链表的方式实现栈

```c
struct Node {
    int data;
    struct Node* next;
};

struct Stack {
    int size;
    struct Node* top;
};

struct Stack* createStack() {
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack->size = 0;
    stack->top = NULL;
    return stack;
}

void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}

int pop(struct Stack* stack) {
    if (stack->size == 0) {
        return -1;
    }
    struct Node* temp = stack->top;
    int data = temp->data;
    stack->top = temp->next;
    free(temp); // temp 的作用就是释放空间
    stack->size--;
    return data;
}
struct Stack* stack = createStack();
```

# 以链表的方式实现队列

```c
struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node *front, *rear;
};

struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

void enQueue(struct Queue* q, int data) {
    struct Node* temp = newNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp;
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

int deQueue(struct Queue* q) {
    if (q->front == NULL)
        return -1;
    struct Node* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL)
        q->rear = NULL;
    free(temp);
    return data;
}
```

# 树

```c
typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};
Tree newnode(int data){
    Tree temp=(Tree)malloc(sizeof(struct TreeNode));
    temp->element=data;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
```

## 从中序遍历和后序遍历得到一个二叉树

```c
Tree newnode(int data);
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N);
int main(void){
    int N;scanf("%d",&N);int inorder[N],postorder[N];
    for(int i=0;i<N;i++){
        scanf("%d",inorder+i);
    }
    for(int i=0;i<N;i++){
        scanf("%d",postorder+i);
    }Tree head=newnode(postorder[N-1]);
    createTree(head,inorder,postorder,0,N,N);
}
Tree createTree(Tree head,int inorder[],int postorder[],int front,int rear,int N){
    Tree temp;
    int z;
    if(front>=rear){
        return NULL;
    }
    int indexh=Find(postorder[rear-1],inorder,0,N);
    int index=front-1;
    for(int i=rear-2;i>=front;i--){
        z=Find(postorder[i],inorder,0,N);
        if(z<indexh){
            index=i;
            break;
        }
    }if(rear-2<front){
        return NULL;
    }
    if(index==front-1){
        head->left=NULL;
        temp=newnode(postorder[rear-2]);
        head->right=temp;
    }else if(index==rear-2){
        head->right=NULL;
        temp=newnode(postorder[index]);
        head->left=temp;
    }else{
        temp=newnode(postorder[rear-2]);
        head->right=temp;
        temp=newnode(postorder[index]);
        head->left=temp;
    }if(head->left!=NULL)
    createTree(head->left,inorder,postorder, front,index+1,N);
    if(head->right!=NULL)
    createTree(head->right,inorder,postorder,index+1,rear-1,N);
}
/*若是想要以zigzagging order输出的话，建立两个栈，第一个栈弹出顶端后依次将左节点和右节点压入第二个栈中；
 *第二个栈弹出顶端后一次将右节点和左节点压入第一个栈中，每个栈空了之后轮换到下一个栈
 */
```

# 堆（优先队列）Priority Queue

```c
typedef struct HeapStruct *PriorityQueue;
struct HeapStruct {
    ElementType  *Elements;
    int Capacity;
    int Size;
};
// 其实更多以数组的方式实现 左子树：2*index 右子树 2*index+1 父节点 index/2
// 注意，有个dummy head，根节点从index = 1开始
```


注意，d-heap指一个节点有d个孩子（当然还是完全树哦~）
```c
child(i,j) = d*(i-1)+2+j    (i是父亲结点的下标，j是第几个儿子，范围是0~d-1)
parent(i) = (i-2+d)/d         
last_have_leaf = (size()+1)/d    (这是d-heap最后一个有叶子的结点。在heap里是size()/2)
```

# Union & Find

等价关系**R**的三个性质:
- **Reflexive** 自反性：
	- $a\ R\ a,for\ all\ a\in S$
- **Symmetric** 对称性:
	- $a\ R\ b\ if\ and\ only\ if\ b\ R\ a$
- **Transitive** 传递性：
	- $a\ R\ b\ and\ b\ R\ c\ implies\ that\ a\ R\ c$

> 注意:
> 如果要给长度为N的Union(数组实现)付初值(即全为-1)，不能采用如下写法:
```c
    int N;
    scanf("%d",&N);
    int uni[N+1] = {-1}; 
    /*
    *实际上uni[N+1] = {0};也是不允许的，数组长度为变量的话不能赋初值；
    *况且这里写-1最多也只能把第一个赋为-1（即为-1,0,0,0,...）
    */
    --- --- --- --- ---
    //正确写法如下:
    int N;
    scanf("%d",&N);
    int uni[N+1]; 
    for(int i=1;i<N+1;i++){ //这里时间复杂度为O(N) ，将整个代码都拉跨了，有什么办法呢？
        uni[i]=-1;
    }
```


```C
//优化过的find算法，找root的时候顺便减少了depth
//递归版本
SetType Find ( ElementType X , DisjSet S ){

if ( S[ X ] <= 0 )
	return X;
else 
	return S[ X ] = Find( S[ X ], S );
}
```

```c
//迭代版本
SetType  Find ( ElementType  X, DisjSet  S ){   
	ElementType  root,  trail,  lead;

    for ( root = X; S[ root ] > 0; root = S[ root ] );  // find the root
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[ trail ] ;  
       S[ trail ] = root ;  
    }  //把路上遇到的节点全连接到root上
    return  root ;
}
```

```c
void SetUnion(ElementType n1, ElementType n2, DisjSet S){
	Element root1, root2;
	root1 = Find(n1,S);
	root2 = Find(n2,S);
	if(-S[root1] > -S[root2]){
		S[root1]+=S[root2];
		S[root2]=root1;
	}else{
		S[root2]+=S[root1];
		S[root1]=root2;
	}
}
```

